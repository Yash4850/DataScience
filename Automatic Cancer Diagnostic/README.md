# Automatic Cancer Diagnostic
It is quite expensive to determine whether a particular patient has cancer or not. With this in mind, local NHS trust hired a software developer to design and develop a 
software capable of automatically making this diagnostic. This software will read CSV files with measurements taken from blood tests of patients and produce a diagnostic.
Unfortunately, for unknown reasons this software developer left mid-project. The NHS trust has now hired me to complete the project. 

The aim of this software is to classify each row of the data matrix (representing the measurements of
one patient). The algorithm you should use is explained in the appendix.
The number of columns of the matrix learning_data and the matrix data must match. The number of
rows of the matrix learning_data and the matrix learning_data_labels must also match. The matrix
learning_data_labels and the matrix data_labels (the latter, generated by your software) must have a
single column. The value of k cannot be larger than the number of rows in the matrix learning_data,
and it must be positive (note: zero is not a positive number).
Your software should follow the algorithm described in the appendix and generate a new matrix
data_labels. This matrix should have a single column and the same number of rows as the matrix
data. The entry (x,1) of the matrix data_labels will contain an integer representing the label of the row
x of the matrix data. A zero means patient x does not have Cancer and a one means the opposite.
Notice: the matrix data_labels and the matrix correct_data_labels should each have a single column,
and they should have the same number of rows.
6
# Appendix
Data standardization
ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(ğ‘¥, ğ‘¦) =
ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(ğ‘¥, ğ‘¦) âˆ’ ğ‘ğ‘£ğ‘”(ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(: , ğ‘¦))
ğ‘ ğ‘¡ğ‘‘(ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(: , ğ‘¦))
where, x is a non-negative integer representing a row number, y is a non-negative integer
representing a column number, avg(matrix(:,y)) is the average of column y over all the rows, and
std(matrix(:,y)) is the corrected sample standard deviation of column y over all the rows.
The corrected sample standard deviation of the column y over all rows, matrix(:,y), is given by:
ğ‘ ğ‘¡ğ‘‘(ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(: , ğ‘¦)) = âˆš
1
ğ‘âˆ’1
âˆ‘ (ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(ğ‘–, ğ‘¦) âˆ’ ğ‘ğ‘£ğ‘”(ğ‘šğ‘ğ‘¡ğ‘Ÿğ‘–ğ‘¥(: , ğ‘¦)))
2
ğ‘
ğ‘–=1
,
where N is the number of rows in the matrix.
Classification algorithm
1. Set a positive value for k.
2. For each row x in the matrix data
 a. Find the k rows in the matrix learning_data that are the closest to the row x in the matrix data
according to the Euclidean distance (see below).
 b. Given the rows found on Step 2(a), find the values of the same row numbers in the matrix
learning_data_labels.
 c. Given the values found in Step 2(b), find the most common value (that with the highest
frequency). If two (or more) values have the same frequency, choose one of them at random.
 d. Set the row x of the matrix data_labels to the value found in Step 2(c).
Euclidean distance:
The Euclidean distance between a list_a and a list_b (both of size M) is given by:
ğ‘‘ = âˆšâˆ‘(ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘
(ğ‘¦) âˆ’ ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘
(ğ‘¦))
2
